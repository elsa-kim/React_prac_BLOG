# 백엔드

백엔드 프로그래밍(서버 프로그래밍) : 어떤 종류의 데이터를 몇 개씩 보여줄지, 어떻게 보여줄지 등에 관한 로직 만드는 것

## Node.js

자바스크립트 엔진을 기반으로 웹 브라우저뿐 아니라 서버에서도 자바스크립트를 사용할 수 있는 런타임 개발한 것

- Node.js 환경에서 웹 서버 구축할 때 보통 Express, Hapi, Koa 등의 웹 프레임워크 사용

## Koa

Express 개발 팀이 개발한 프레임워크

- Express VS Koa
  - Express : 미들웨어, 라우팅, 템플릿, 파일 호스팅 등과 같은 다양한 기능 자체적 내장
  - Koa : 미들웨어 기능만 갖추고 있으며 나머지는 다른 라이브러리 적용해 사용, 필요한 기능들만 붙여 서버 만들 수 있기 때문에 Express보다 훨씬 가벼움, async/await 문법 정식지원해 비동기 작업 더 편리하게 관리 가능

### 미들웨어

Koa 애플리케이션은 미들웨어의 배열로 구성되어 있음, 미들웨어 함수는 두 개의 파라미터 받음

- 미들웨어 함수 구조 : (ctx, next) => {}
  - ctx : Context의 줄임말로 웹 요청과 응답에 관한 정보 지님
  - next : 현재 처리중인 미들웨어의 마음 미들웨어를 호출하는 함수, 미들웨어 등록하고 next 함수 호출하지 않으면 그 다음 미들웨어 처리하지 않음, 미들웨어에서 next 사용하지 않으면 파라미터에 설정 안해도 됨(주로 다음 미들웨어 처리할 필요 없는 라우트 미들웨어를 나중에 설정할 때 이러한 구조 사용)
- 미들웨어는 app.use 사용해 등록되는 순서대로 처리됨

### next 함수는 Promise 반환

- Koa가 Express와 차별화되는 부분
- next 함수가 반환하는 Promise는 다음에 처리해야 할 미들웨어가 끝나야 완료됨

### async/await 사용

- Express도 async/await 문법 사용할 수 있지만 오류 처리하는 부분 제대로 작동 안할 수 있음, 예상치 못한 에러 잡아내려면 express-async-errors 라이브러리 사용해야 함

### koa-router 사용

다른 주소로 요청 들어올 경우 다른 작업 처리할 수 있도록 라우터 사용해야하는데 Koa 자체에 내장되어 있지않아 koa-router 모듈 설치해야 함

- 라우트 설정시 첫번째 파라미터에는 라우트 경로를 넣고, 두번째 파라미터에는 해당 라우트에 적용할 미들웨어 함수 넣음

#### 라우트 파라미터와 쿼리

- 파라미터 :
  - '/about/:name' 형식으로 콜론 사용
  - 파라미터 있을 수도 있고 없을 수도 있다면 파라미터 이름 뒤 물음표 사용
  - 파라미터 함수는 ctx.params 객체에서 조회 가능
  - 처리할 작업의 카테고리 받아오거나 고유 ID, 이름으로 특정 데이터 조회할 때 사용
- URL 쿼리 :
  - '/posts/?id=10' 형식으로 값 요청
  - ctx.query에서 조회 가능
  - 문자열 형태 쿼리 문자열 조회해야 할 때는 ctx.querystring 사용
  - 옵션에 관련된 정보 받아올 때 사용

#### REST API

- 클라이언트가 서버에 데이터 조회, 생성, 삭제, 업데이트하겠다고 요청하면 서버는 필요한 로직에 따라 데이터베이스에 접근해 작업 처리
- REST API는 요청 종류에 따라 다른 HTTP 메서드 사용
  - GET : 데이터 조회할 때 사용
  - POST : 데이터 등록할 때 사용, 인증 작업 거칠 때 사용하기도 함
  - DELETE : 데이터 지울 때 사용
  - PUT : 데이터 새 정보로 통째로 교체할 때 사용
  - PATCH : 데이터 특정 필드 수정할 때 사용
- GET 메서드 사용 API는 웹 브라우저에서 주소 입력해 테스팅할 수 있지만 POST, DELETE, PUT, PATCH 메서드 사용하는 API는 자바스크립트로 호출해야 함 or Postman 프로그램 사용

#### 라우트 모듈화

프로젝트 진행 시 여러 종류의 라우트 만들게 되는데, 각 라우트를 index.js 파일 하나에 모두 작성하면 코드 길어지고 유지보수 힘들어짐
=> 라우터를 여러 파일에 분리시켜 작성하고, 이를 불러와 적용

#### 컨트롤러 파일 작성

라우트 처리 함수의 코드 길면 라우터 설정 한눈에 보기 힘듦
=> 라우트 처리 함수들을 다른 파일로 따로 분리해 관리 가능 = 컨트롤러

- 컨트롤러 만들때 exports.이름 = ... 형식으로 함수 내보내줌
- 불러올 때 형식:

```
const 모듈이름 = require('파일이름');
모듈이름.이름();
```

## 데이터베이스

웹 서비스에서 사용되는 데이터 저장하고, 효율적으로 조회하거나 수정 가능

1. 관계형 데이터베이스(RDBMS)

- MySQL, OracleDB, PostgreSQL 등
- 몇가지 한계
  - 데이터 스키마 고정적 : 새로 등록하는 데이터 형식이 기존 데이터들과 다르면 기존 데이터 모두 수정해야 함
  - 확장성 : 저장하고 처리해야 할 데이터양 늘어나면 여러 컴퓨터에 분산시키는 것이 아닌, 해당 데이터베이스 서버의 성능 업그레이드 하는 방식으로 확장
- ACID 특정 지켜야 할 때 유리 : ACID는 원자성(Atomicity), 일관성(Consistency), 고립성(Isolation), 지속성(Durability)의 앞글자 따서 만든 용어로, 데이터베이스 트랜잭션이 안전하게 처리되는 것 보장하기 위한 성질 의미

2. NoSQL 데이터베이스

- MongoDB 등
- 유동적인 스키마(데이터베이스에 어떤 형식의 데이터 넣을지에 대한 정보) 지닐 수 있고 데이터 양 늘어나도 여러 컴퓨터로 분산해 처리할 수 있도록 확장 쉽계 설계
- 데이터 구조 자주 바뀔때 유리

### MongoDB

#### 문서(document)

- RDBMS의 레코드와 개념 비슷
- 문서 데이터 구조는 한 개 이상의 키-값 쌍으로 되어있음
- BSON(바이너리 형태의 JSON) 형태로 저장되어 JSON 형태의 객체를 데이터베이스에 저장할 때 편리
- 새로운 문서 만들면 \_id라는 고유값 자동 생성 : 시간, 머신아이디, 프로세스아이디, 순차번호로 되어있어 값 고유함 보장
- 컬렉션 : 여러 문서 들어있는 곳(기존 RDBMS에서는 테이블 개념 사용, 각 테이블마다 같은 스키마 가져야 함)

#### MongoDB 구조

서버 하나에 데이터베이스 여러개 가질 수 있으며, 각 데이터베이스에는 여러 개의 컬렉션이 있고, 컬렉션 내부에는 문서들이 들어있음

#### 스키마 디자인

- RDBMS에서 디자인하는 방식과 완전히 다름
  - RDBMS ex) 블로그용 데이터 스키마 설계시 각 포스트, 댓글마다 테이블 만들어 필요에 따라 JOIN해 사용
  - NoSQL에서는 모든 것을 문서 하나의 넣음
- 문서 내부에 또 다른 문서가 위치할 수 있는데, 이를 서브다큐먼트(subdocument)라고 함, 문서하나는 16MB 데이터까지 가능한데 서브다큐먼트에서 용량 초과할 가능성 있다면 컬렉션 분리시키는 것이 좋음

#### mongoose

Node.js 환경에서 사용하는 MongoDB 기반 ODM(Object Data Modelling) 라이브러리

#### dotenv

환경변수들을 파일에 넣고 사용할 수 있게 하는 개발 도구로, 민감하거나 환경별로 달라질 수 있는 값은 코드 안에 직접 작성하지 않고 환경변수로 설정하는 것이 좋음

- Node.js에서 환경변수는 process.env 값 통해 조회 가능

### 데이터베이스의 스키마와 모델

mongoose에는 스키마(schema)와 모델(model)이라는 개념 존재

- 스키마 : 컬렉션에 들어가는 문서 내부의 각 필드가 어떤 형식으로 되어 있는지 정의하는 객체
  - 스키마 만들 때 mongoose 모듈의 Schema 사용해 정의, 각 필드 이름과 필드 데이터 타입 정보 들어있는 객체 작성
  - 필드 기본값으로는 default값 설정
  - 지원 타입 : String;문지열, Number;숫자, Date;날짜, Buffer;파일 담을 수 있는 버퍼, Boolean;true나 false 값, Mixed(Schema.Types.Mixed);어떤 데이터도 넣을 수 있는 형식, ObjectId(Schema.Types.ObjectId);객체 아이디(주로 다른 객체 참조할 때 넣음), Array;배열 형태의 값으로 []로 감싸서 사용
  - 스키마 내부에 다른 스키마 내장시킬 수 있음
- 모델 : 스키마 사용해 만드는 인스턴스로, 데이터베이스에서 실제 작업을 처리할 수 있는 함수들을 지니고 있는 객체
  - mongoose.model 함수 사용
    - 두개 파라미터 필요 : 첫번째 파라미터는 스키마 이름, 두번째 파라미터는 스키마 객체
    - 데이터베이스는 스키마 이름 정해주면 그 이름 복수형태로 데이터베이스에 컬렉션 이름 만듦, 따로 정하고 싶으면 세 번째 파라미터에 입력

#### 데이터 생성과 조회

- 포스트의 인스턴스 만들때는 new 키워드 사용, 생성자 함수의 파라미터에 정보 지닌 객체 넣음
- 인스턴스 만들고 save() 함수 실행시켜야 데이터베이스에 저장됨
  - 함수 반환 값은 Promise이므로 async/await 문법으로 데이터 요청 완료할 때까지 await 사용해 대기 가능
  - await 사용하려면 함수 선언 부분 앞 async 키워드 넣고, try/catch 문으로 오류 처리해야 함
- 데이터 조회할 때는 모델 인스턴스의 find() 함수 사용
  - find() 함수 호출 후 exec() 붙여줘야 서버에 쿼리 요청
- 특정 포스트 조회하려면 id로 찾아 조회
  - 특정 id 가진 데이터 조회 시 findById() 함수 사용
- 데이터 삭제할 땐 여러 종류 함수 사용 가능
  - remove() : 특정 조건 만족하는 데이터 모두 지움
  - findByIdAndRemove() : id 찾아 지움
  - findOneAndRemove() : 특정 조건 만족하는 데이터 하나 찾아서 제거
- 데이터 업데이트할 때는 findByIdAndUpdate() 함수 사용
  - 세가지 파라미터 넣어줘야 함 : 첫번째는 id, 두번째는 업데이트 내영, 세번째는 업데이트의 옵션

### 검증

#### ObjectId 검증

500 오류는 보통 서버에서 처리하지 않아 내부적으러 문제 생겼을 때 발생, 잘못된 id 전달했다면 클라이언트가 요청 잘못보낸 것이므로 400 Bad Request 오류 띄워주는게 맞음 => id 값이 올바른 ObjectId인지 확인해야 함

- 검증방법 :

```
import mongoose from 'mongoose';

const { ObjectId } = mongoose.Types;
ObjectId.isValid(id);
```

- 미들웨어 만들어 한번만 구현한 다음 여러 라우트에 적용

#### Request Body 검증

포스트 작성시 서버는 title, body, tags 값을 모두 전달받아야 하는데, 클라이언트가 값을 빼먹었을때 400 오류 발생해야 함

- 검증방법 :
  - 각 값을 if문으로 비교
  - Joi 라이브러리 사용

### 페이지네이션 구현

불필요하게 모든 내용 불러오면 로딩 속도 지연되고 트래픽 낭비됨
=> 페이지네이션(pagination) 기능 구현

- 역순으로 불러오게 구현하려면 list API에서 exec() 하기 전 sort() 구문 넣기
  - sort 함수 파라미터는 {key:1} 형식으로, key는 정렬할 필드 설정하는 부분이고 오른쪽 값을 1로 설정시 오름차순, -1로 설정시 내림차순으로 정렬됨
- limit() 함수 : 한번에 보이는 개수 제한, 파라미터에 제한할 숫자 입력
- skip() 함수 : 파라미터 만큼 제외하고 그 다음 데이터 불러옴
- 마지막 페이지 알려주는 방법 :
  - 응답 내용 형식 바꿔 새로운 필드 설정
  - Response 헤더 중 Link 설정
  - 커스텀 헤더 설정 => 사용
- 내용 길이 제한 : find() 통해 조회한 데이터는 mongoose 문서 인스턴스의 형태이므로 데이터를 바로 변형할 수 없음, 대신 toJSON() 함수 실행해 JSON 형태로 변환한 뒤 필요한 변형 일으켜줘야 함, lean() 함수 사용하는 방법도 있음

## JWT

JSON Web Token 약자로, 데이터가 JSON으로 이뤄져있는 토큰을 의미함. 두 개체가 서로 안전하게 정보를 주고받을 수 있도록 웹 표준으로 정의된 기술

### 세션 기반 인증과 토큰 기반 인증의 차이

사용자의 로그인 상태를 서버에서 처리하는 데 사용할 수 있는 대표적인 두가지 인증 방식

1. 세션 기반으로 인증 : 서버가 사용자가 로그인 중임을 기억하고 있는 것

- 서버는 세션 저장소에 사용자 정보를 조회하고 세션 id 발급, 발급된 id는 주로 브라우저 쿠키에 저장
- 사용자가 다른 요텅 보낼 때마다 서버는 세션 저장소에서 세션 조회한 후 로그인 여부 결정해 작업 처리하고 응답
- 세션 저장소는 주로 메모리, 디스크, 데이터베이스 등 사용
- 단점 : 서버 확장 번거로움(서버 인스턴스 여러개 된다면 모든 서버끼리 같은 세션 공유해야 되므로 세션 전용 데이터베이스 만들어야 함)

2. 토큰 기반으로 인증

- 토큰 : 로그인 이후 서버가 만들어주는 문자열로, 해당 문자열 안에는 사용자의 로그인 정보가 들어있고 해당 정보가 서버에서 발급되었음을 증명하는 서명 들어있음
- 서버에서 만들어준 토큰은 서명이 있기때문에 무결성 보장됨
- 사용자가 로그인 하면 서버에서 사용자에게 해당 사용자의 정보 지니고 있는 토큰 발급해주고, 추후 사용자가 다른 API 요청하게 될 때 발급받은 토큰과 함께 요청 => 서버는 해당 토큰이 유효한지 검사하고, 결과에 따라 작업 처리, 응답함
- 장점 :
  - 서버에서 사용자 로그인 정보를 기억하기 위해 사용하는 리소스가 적음
  - 사용자쪽에서 로그인 상태 지닌 토큰 가지고 있으므로 서버의 확장성 매우 높음
  - 서버 인스턴스 여러개로 늘어나도 서버끼리 사용자의 로그인 상태 공유하고 있을 필요 없음
